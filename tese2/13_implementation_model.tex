\section{Model}
The model is the most important component of our solution, a badly designed model can imply serious difficulties when implementing new features that are not part of the plans, sometimes we had to redesign the model in order to support new features.

\subsection {Schema representation}
    \emph{MongoDB} has a slightly different terminology from relational databases. The first big difference is instead of having tables \emph{MongoDB} stores its objects on collections. The analogous data structure to the table row is a document.

    Each \emph{MongoDB} document is represented by a \emph{JSON} object and, as a result, each document may have different attributes within a collection. Needless to say that following this approach we don't need to create the collections with a well predefined schema, in fact we don't to define it at all. Although, for reasons of coherence and organization, we represent our database collections as they would have a predefined schema by following the same document structure.

    Similarly to relational databases, \emph{MongoDB} requires a primary key (typically typed as \emph{ObjectId} and named \emph{"\_id"}) for each document which is automatically assigned if not specified. 

    In order to define \emph{foreign keys}, we just store them as \emph{ObjectId}s if and only if the foreign keys point to documents within a unique collection, otherwise we need an additional attribute to specify which collection is the \emph{foreign key} pointing at.

    In respect to attributes nullability, \emph{MongoDB} does not enforce a document's attribute to have a non nullable value, although, for sake of good functionality, we perform those constraints validation programatically and by so we also represent them in our schema.

    An example of schema representation can be seen on table \ref{table:schema}.

\begin{table}[!htb]
\centering
\caption{Schema representation}
\label{table:schema}
    \begin{tabular}{|ll|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Collection name}}       \\ \hline
        $\Diamondblack$ \underline{\_id (primary key)}  & ObjectId   \\ 
        $\medbullet$ Not nullable property name           & Property type                    \\ 
        $\medcirc$ Nullable property name      & Property type                         \\
        $\medcirc$ Reference to document     & ObjectId                         \\
        $\medbullet$ Embedded document      & Document                         \\ 
        $\medbullet$ Embedded list      & List[Type]                         \\ \hline
        
        
    \end{tabular}
\end{table}

\subsection {Generic model}

For designing our model we have taken into account generic programming techniques. We observed that operations like searching for an object was quite repeated amongst different types of objects. 

Our first decision for our model in order to avoid repeated code, was the isolation of the object's attributes from themselves, so we could apply the search operation to a set of attributes independently from the object type. To this generic set of properties we call data and each object of this type has a reference to the owner, which is a unique identification number.

\begin{table}[!htb]
\centering
\caption{Generic data model}
\label{my-label}
    \begin{tabular}{cc}
        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{Data}}                                \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                         \\ 
            $\medbullet$ owner           & ObjectId                            \\ 
            $\medbullet$ properties      & List[Attribute] \\ 
            $\medcirc$ searchableValues & List[Text]        \\ \hline
        \end{tabular}
        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{Attribute}}                           \\ \hline
            $\medbullet$ key           & Text                                  \\ 
            $\medcirc$ value           & Object                              \\ 
            $\medbullet$ identifiable    & Boolean                             \\ 
            $\medcirc$ readPermissions &  List[ObjectId]   \\ 
            $\medcirc$ writePermissions  & List[ObjectId]  \\ \hline
        \end{tabular}    
    \end{tabular}
\end{table}

The identification number by itself is not sufficient to identify an object, objects from different types can have the same identification number. In order to solve this problem, when an object is created, its correspondent data must contain the owner's object type. 

Whenever an attribute is created, it must be specified the attributes name, its value, searcheability, identifiability and the set of object identification numbers that can read and write that attribute. 

In relation to our permission mechanism, if the read or write sets are not specified we assume the attribute is readable and writable by everyone, conversely if the read and write sets are empty, nobody is allowed to read or write the attribute. Implicitly if an entity can write an attribute it can also read it.

In particular, if all attributes were searchable it could be simple to search for attributes that could reveal sensible information about an object. For example if we consider that a user could have a health related attribute, searching by a disease would reveal which users could suffer from a certain disease, the leak of that kind of information could, for instance, change the agreement between users and health insurance companies. For this reason only the specified attributes as searchable will be taken into account when performing keyword searches.

Another important attribute specification is the owner identifiability, which tells us if the attribute identifies the object. This specification let us create abstract authentication services, for example a user can login into our system by providing any attribute that identifies himself, for example the e-mail but others are possible like the user name or cellphone number. 

Not less important, in order to get an object properties efficiently, we have created an index over the \emph{owner} attribute. In the meantime , we have also created an index over the \emph{searchableValues} in order to improve the keyword search performance.

In summary, with this model we can perform search and identification of any kind of objects, as we will see on the following models, the \emph{user} and \emph{group} models are using this generic model for storing their attributes. 
% Not less important, attributes can specify aggregations of objects. For example, the user role is an aggregator property that within users it allows the identifaction of each one is administrator. This aggregation specification is independent from the object type, so it's possible to search for the administrative role and return users and groups of users that contains that property. <= [currently this operation is possible but it is not specified]


\subsection{User model}

The user model is not tied to the user attributes, the information maintained in this model is just used for authentication purposes. Passwords are not stored in plain text, instead we apply hashing and salting techniques \cite{password} in order to make it harder to decode the password by an attacker. Accordingly, we use \emph{SHA-1} and a random salt per user with 32 characters long.

\begin{table}[!htb]
\centering
\caption{User model}
\label{my-label}
    \begin{tabular}{|ll|}
        \hline
        \multicolumn{2}{|c|}{\textbf{User}}                             \\ \hline
        $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
        $\medbullet$ hash           & Text                         \\ 
        $\medbullet$ salt      & Text                         \\ \hline
    \end{tabular}
\end{table}

\subsection{Relation model}

A relation between two entities $e_1$ and $e_2$ is represented by the pair $e_1\rightarrow e_2$, where $e_1$ is the source and $e_2$ is the target. This relation is said bi-directional if and only if it also exists the relation $e_2\rightarrow e_1$.

\begin{table}[!htb]
\centering
\caption{Relation model}
\label{my-label}
    \begin{tabular}{|ll|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Relation}}                             \\ \hline
        $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
        $\medbullet$ source           & ObjectId                         \\ 
        $\medbullet$ target      & ObjectId                         \\ \hline
    \end{tabular}
\end{table}

A user can only interact with friends or with group members. In order to validate a friendship, both users must agree on that friendship, by other words it must exist a bi-directional relation between both users.

\subsection{Group model}

A group can be public or private. If the group is public then it is visible to all users that maintain a friendship with a member of this group. If the group is private then it is only visible to their members.

\begin{table}[!htb]
\centering
\caption{Group model}
\label{my-label}
    \begin{tabular}{cc}
        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{Group}}                             \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
            $\medcirc$ inviteToken           & Text                         \\ 
            $\medbullet$ visibility      & Text                         \\ \hline
        \end{tabular}

        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{GroupMembership}}                   \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
            $\medbullet$ groupId           & ObjectId                         \\ 
            $\medbullet$ userId & ObjectId                           \\ \hline
        \end{tabular}    
    \end{tabular}
\end{table}


The group membership is a special case of relation, where the target entity is always a group.

When a group is created, a group membership is automatically assigned by its creator.

Entities that have a membership with a group can create more memberships by sharing an invite token or by specifying new group members.

\subsection{Message model}

A message is composed by its content, sequence number, time of creation and source and target identification numbers. The message's target can reference any of object but our application is only covering messages to groups.

\begin{table}[!htb]
\centering
\caption{Message model}
\label{my-label}
    \begin{tabular}{|ll|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Message}}                             \\ \hline
        $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
        $\medbullet$ source           & ObjectId                         \\ 
        $\medbullet$ target      & ObjectId                         \\ 
        $\medbullet$ sequence      & Number                         \\ 
        $\medbullet$ content      & Text                         \\ \hline
    \end{tabular}
\end{table}

\subsection{Hyper content model}

During a group conversation it is possible to create time annotations for making it easy to access that time either by searching or sharing with other users.

A time annotation contains a title, the correspondent group identification number and the time itself.

The hyper content is used to synchronize content among users during a conversation. Every hyper content must have a start and ending time, the correspondent group identification number and the content itself in the form of text.


\begin{table}[!htb]
\centering
\caption{Hyper content model}
\label{my-label}
    \begin{tabular}{cc}
        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{HyperContent}}                             \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
            $\medbullet$ groupId            & ObjectId                         \\ 
            $\medbullet$ start              & Date                         \\ 
            $\medbullet$ end                & Date                         \\ 
            $\medbullet$ content            & Text                         \\ \hline
        \end{tabular}

        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{TimeAnnotation}}                   \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
            $\medbullet$ groupId            & ObjectId                         \\ 
            $\medbullet$ title & Text                           \\ 
            $\medbullet$ time & Date                           \\ \hline

        \end{tabular}    
    \end{tabular}
\end{table}


\subsection{Collaborative Content model}

Within a conversation, users can write documents collaboratively. Each document has a content and a reference to the correspondent group. 


\begin{table}[!htb]
\centering
    \caption{Collaborative content model}
    \label{my-label}
    \begin{tabular}{|ll|}
        \hline
        \multicolumn{2}{|c|}{\textbf{CollaborativeContent}}                             \\ \hline
        $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
        $\medbullet$ groupId            & ObjectId                         \\ 
        $\medbullet$ content            & Text                         \\ \hline
    \end{tabular}
\end{table}

\subsection{Recording model}

During a conversation, users may allow sharing their web cameras, by doing so their video is stored in recording chunks. Each chunk represents an interval of time  $T=\big[c^{start},c^{end}\big[$, it contains a reference to a group and list of \ac{URL}s with the correspondent owner identification number and \emph{WebSocket} session id.

In order to allow different devices within the same user, storing just the \ac{URL} with an associated user id is not enough as in this case it is needed one more parameter to differentiate the different \emph{webSocket} sessions opened by the same user. For this reason we had to associate a random session identification number to each \emph{webSocket}.

\begin{table}[!htb]
\centering
    \caption{Recording model}
    \label{my-label}
    \begin{tabular}{cc}
        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{RecordingInterval}}                   \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
            $\medbullet$ groupId            & ObjectId                         \\ 
             $\medbullet$ start             & Date                         \\ 
            $\medbullet$ end                & Date                         \\ \hline
        \end{tabular}   
        \begin{tabular}{|ll|}
            \hline
            \multicolumn{2}{|c|}{\textbf{RecordingChunk}}                             \\ \hline
            $\Diamondblack$ \underline{id}  & ObjectId                      \\ 
            $\medbullet$ groupId            & ObjectId                         \\ 
            $\medbullet$ interval           & ObjectId                      \\ 
            $\medbullet$ start              & Date                         \\ 
            $\medbullet$ end                & Date                         \\ 
            $\medbullet$ sequenceNumber     & Number                         \\ 
            $\medbullet$ urls               & Document                       \\ \hline
        \end{tabular}
    \end{tabular}
\end{table}



A set of chunks $S=[c_1,c_2,\ldots,c_n]$ is said continuous if $\forall c_i\in S, \exists c_j \in S$ where $j\neq i$ and $c_i^{start} = c_j^{end} \vee c_i^{end} = c_j^{start}$. 

A recording interval represents a continuous set of recording chunks.
